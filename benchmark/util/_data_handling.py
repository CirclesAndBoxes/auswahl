import pandas as pd
import numpy as np
import os
import warnings

from typing import List, Union, Literal

"""
    TODO: - Allow the handling of different datasets
          - include execution time --> fits perfectly into the regression frame
          - Enforce a visually pleasant sorting

"""


class BenchmarkPOD:

    """
        Plain Old Dataobject corralling data generated by benchmarking different wavelength selection methods
    """

    def __init__(self,
                 methods: List,
                 n_features: List[int],
                 reg_metrics: List,
                 stab_metrics: List,
                 n_runs: int):

        methods = sorted(methods)  # canonical order of methods
        reg_index, reg_size = self._build_multiindex([
            n_features,
            reg_metrics,
            ['mean', 'std', *[f'sample_{i}' for i in range(n_runs)]]
        ])
        stab_index, stab_size = self._build_multiindex([
            n_features,
            stab_metrics,
        ])
        selection_index, selection_size = self._build_multiindex([
            n_features,
            [f'sample_{i}' for i in range(n_runs)],
            [f'feature_{i}' for i in range(max(n_features))]
        ])

        self.selection_data = pd.DataFrame(-1 * np.ones((len(methods), selection_size), dtype='int'), index=methods, columns=selection_index)
        self.stab_data = pd.DataFrame(np.zeros((len(methods), stab_size), dtype='float'), index=methods, columns=stab_index)
        self.reg_data = pd.DataFrame(np.zeros((len(methods), reg_size), dtype='float'), index=methods, columns=reg_index)

        self.methods = methods
        self.reg_metrics = reg_metrics
        self.stab_metrics = stab_metrics
        self.max_features = n_features
        self.n_runs = n_runs
        self.n_features = n_features

        self.meta = dict()

    def _build_multiindex(self, structure: List[List[str]]):
        index = np.array([structure[-1]])
        for i in range(len(structure) - 2, -1, -1):
            index = np.concatenate([
                np.repeat([structure[i]], repeats=index.shape[1], axis=1),
                np.tile(index, (1, len(structure[i])))
            ])
        return index.tolist(), index.shape[1]

    def register_meta(self, **kwargs):
        for key in kwargs.keys():
            self.meta[key] = kwargs[key]

    def _make_regression_key(self,
                             method: Union[str, List[str]] = None,
                             n_features: Union[int, List[int]] = None,
                             reg_metric: Union[str, List[str]] = None,
                             item: Literal['mean', 'std', 'samples'] = None,
                             sample_number: Union[int, List[int]] = None):
        if item == 'samples':
            if sample_number is None:
                item = [f'sample_{i}' for i in range(self.n_runs)]
            elif type(sample_number) == list:
                item = [f'sample_{i}' for i in range(sample_number)]
            else:
                item = f'sample_{sample_number}'
        method_key = method if method is not None else slice(None)
        key = (
                #method if method is not None else slice(None),
                self._string_conversion(n_features) if n_features is not None else slice(None),
                reg_metric if reg_metric is not None else slice(None),
                item if item is not None else slice(None)
              )
        return method_key, key

    def register_regression(self,
                            value, #TODO: type information
                            method: Union[str, List[str]] = None,
                            n_features: Union[int, List[int]] = None,
                            reg_metric: Union[str, List[str]] = None,
                            item: Literal['mean', 'std', 'samples'] = None,
                            sample_number: int = None):
        method_key, key = self._make_regression_key(method, n_features, reg_metric, item, sample_number)
        if type(value) == pd.DataFrame:
            self.reg_data.loc[(method_key, key)] = value.values.tolist()
        elif type(value) == np.array:
            self.reg_data.loc[(method_key, key)] = value.tolist()
        else:
            self.reg_data.loc[(method_key, key)] = value

    def register_selection(self,
                           method_key: str,
                           n_features,
                           sample,
                           selection: np.array):
        with warnings.catch_warnings():  # TODO: do something about that
            warnings.filterwarnings("ignore")
            self.selection_data.loc[method_key,
                                    (str(n_features),
                                     f'sample_{sample}')].iloc[:selection.shape[0]] = selection.tolist()

    def register_stability(self,
                           n_features,
                           metric_name,
                           value,
                           method_key=None):
        self.stab_data.loc[method_key if method_key is not None else slice(None),
                           (str(n_features),
                            metric_name)] = value

    def _string_conversion(self, item):
        if type(item) == list:
            return [str(i) for i in item]
        return str(item)

    def get_regression_data(self,
                            method: Union[str, List[str]] = None,
                            n_features: Union[int, List[int]] = None,
                            reg_metric: Union[str, List[str]] = None,
                            item: Literal['mean', 'std', 'samples'] = None
                            ):
        """
            Retrieve data related to the regression performance of feature selection methods

            Parameters
            ----------
            method : str or list of str, default=None
                method(s) to be retrieved. If None, all methods are retrieved
            n_features : int or list of int, default=None
                results for the runs with the respective number of selected features to be retrieved. If None,
                the runs for all numbers of selected features are retrieved
            reg_metric : str or list of str, default=None
                regression metric(s) to be retrieved. If None, all available metrics are retrieved
            item : Literal of ['mean', 'std', 'samples'], default=None
                specify, which indicator(s) for the selected regression metrics is to be retrieved.
                If None, all indicators are retrieved

            Returns
            -------
            pandas multiIndex DataFrame sliced to the requested data
        """
        method_key, key = self._make_regression_key(method, n_features, reg_metric, item)
        return self.reg_data.loc[(method_key, key)]

    def get_selection_data(self,
                           method: Union[str, List[str]] = None,
                           n_features: Union[int, List[int]] = None,
                           sample_run: Union[int, List[int]] = None,
                           selected_features: Union[int, List[int]] = None):
        """
            Retrieve data related to the regression performance of feature selection methods.

            Parameters
            ----------
            method : str or list of str, default=None
                method(s) to be retrieved. If None, all methods are retrieved
            n_features : int or list of int, default=None
                results for the runs with the respective number of selected features to be retrieved. If None,
                the runs for all numbers of selected features are retrieved
           sample_run : int or list of int, default=None
                the run(s) for which the selected features are to be retrieved. If None, the selected features
                of all runs are retrieved.

            Returns
            -------
            pandas multiIndex DataFrame sliced to the requested data
        """

        # constructs multiIndex-slice
        if sample_run is not None:
            if type(sample_run) == list:
                sample_run = [f'sample_{i}' for i in sample_run]
            else:
                sample_run = f'sample_{sample_run}'
        if n_features is not None \
                and type(n_features) != list \
                and selected_features is None:
            selected_features = [f'feature_{i}' for i in range(n_features)]

        method_key = method if method is not None else slice(None)
        key = (
            self._string_conversion(n_features) if n_features is not None else slice(None),
            sample_run if sample_run is not None else slice(None),
            selected_features if selected_features is not None else slice(None)
        )
        with warnings.catch_warnings():  #TODO: do something about that
            warnings.filterwarnings("ignore")
            frame = self.selection_data.loc[method_key, key]
            return frame.sort_index(level=0)

    def get_stability_data(self,
                           method: Union[str, List[str]] = None,
                           n_features: Union[int, List[int]] = None,
                           stab_metric: Union[str, List[str]] = None):
        """
            Retrieve data related to the stability of feature selection methods

            Parameters
            ----------
            method : str or list of str, default=None
                method(s) to be retrieved. If None, all methods are retrieved
            n_features : int or list of int, default=None
                results for the runs with the respective number of selected features to be retrieved. If None,
                the runs for all numbers of selected features are retrieved
            stab_metric : str or list of str, default=None
                stability metric(s) to be retrieved. If None, all available metrics are retrieved

            Returns
            -------
            pandas multiindex DataFrame sliced to the requested data
        """

        # constructs multiIndex-slice
        method_key = method if method is not None else slice(None)
        key = (
            self._string_conversion(n_features) if n_features is not None else slice(None),
            stab_metric if stab_metric is not None else slice(None)
        )
        return self.stab_data.loc[(method_key, key)]
