
import os
import pandas as pd
import numpy as np
import warnings
import pickle

from typing import List, Union, Literal, Tuple


class BenchmarkPOD:

    """
        Plain Old Dataobject corralling data generated by benchmarking different wavelength selection methods
    """

    def __init__(self,
                 datasets: List[str],
                 methods: List,
                 n_features: List[Union[int, Tuple[int, int]]],
                 feature_keys: List[str],
                 reg_metrics: List,
                 stab_metrics: List,
                 n_runs: int):

        datasets = np.array(sorted(datasets))  # canonical order of datasets
        methods = np.array(sorted(methods))  # canonical order of methods

        # setup indices
        reg_index_arrays, reg_size = self._build_multiindex([
            datasets,
            feature_keys,
            reg_metrics,
            ['mean', 'std', 'median', 'max', 'min', *[i for i in range(n_runs)]]
        ])
        reg_index = pd.MultiIndex.from_arrays(reg_index_arrays, names=['dataset', 'n_features', 'regression_metric', 'item'])

        stab_index_arrays, stab_size = self._build_multiindex([
            datasets,
            feature_keys,
            stab_metrics,
        ])
        stab_index = pd.MultiIndex.from_arrays(stab_index_arrays, names=['dataset', 'n_features', 'stability_metric'])

        # should be fine here (automatic conversion)
        selection_index_arrays, selection_size = self._build_multiindex([
            datasets,
            feature_keys,
            [i for i in range(n_runs)],
            [i for i in range(self._max_n_features(n_features))]
        ])
        selection_index = pd.MultiIndex.from_arrays(selection_index_arrays, names=['dataset', 'n_features', 'run', 'feature'])

        measurement_index_arrays, measurement_size = self._build_multiindex([
            datasets,
            feature_keys,
            ['mean', 'std', 'median', 'max', 'min', *[i for i in range(n_runs)]]
        ])
        measurement_index = pd.MultiIndex.from_arrays(measurement_index_arrays, names=['dataset', 'n_features', 'item'])

        # setup dataframes
        self.selection_data = pd.DataFrame(-1 * np.ones((len(methods), selection_size), dtype='int'),
                                           index=methods,
                                           columns=selection_index)
        self.stab_data = pd.DataFrame(np.NaN * np.zeros((len(methods), stab_size), dtype='float'),
                                      index=methods,
                                      columns=stab_index)
        self.reg_data = pd.DataFrame(np.NaN * np.zeros((len(methods), reg_size), dtype='float'),
                                     index=methods,
                                     columns=reg_index)

        self.measurement_data = pd.DataFrame(np.NaN * np.zeros((len(methods), measurement_size), dtype='float'),
                                             index=methods,
                                             columns=measurement_index)
        # meta data
        self.datasets = datasets
        self.methods = methods
        self.reg_metrics = reg_metrics
        self.stab_metrics = stab_metrics
        self.max_features = n_features
        self.n_runs = n_runs
        self.n_features = n_features
        self.n_datasets = len(datasets)

        self.meta = dict()

    def _build_multiindex(self, structure: List[Union[List[str], np.array]]):
        # construct the hierarchical muliindex
        index = np.array([structure[-1]])
        for i in range(len(structure) - 2, -1, -1):
            index = np.concatenate([
                np.repeat([structure[i]], repeats=index.shape[1], axis=1),
                np.tile(index, (1, len(structure[i])))
            ])
        return index.tolist(), index.shape[1]

    def register_meta(self, dataset_meta: List[Tuple[np.array, np.array, str, float]]):
        if not isinstance(dataset_meta, list):
            dataset_meta = [dataset_meta]
        for x, y, name, _ in dataset_meta:
            self.meta[name] = (x, y, x.shape)

    def _tuple_conversion(self, item):
        if isinstance(item, tuple):
            return f'{item[0]}/{item[1]}'
        else:
            return str(item)

    def _string_conversion(self, item):
        if type(item) == list:
            return [self._tuple_conversion(i) for i in item]
        return self._tuple_conversion(item)

    def _resolve_if_interval(self, item):
        if isinstance(item, tuple):
            return item[0] * item[1]
        else:
            return item

    def _max_n_features(self, n_features):
        features = []
        for f in n_features:
            features.append(self._resolve_if_interval(f))
        return max(features)

    def get_meta(self, dataset):
        """
                    Provides meta information for each dataset
        parameters
        ----------
        dataset: str
            name of the dataset, whose meta information is requested

        returns
        -------
        tuple
            (spectra, targets, (n_samples, n_wavelengths))

        """
        return self.meta[dataset]

    def _make_key(self,
                  dataset: Union[str, List[str]] = None,
                  method: Union[str, List[str]] = None,
                  n_features: Union[int, List[int]] = None,
                  reg_metric: Union[str, List[str]] = None,
                  item: Literal['mean', 'std', 'median', 'max', 'min', 'samples'] = None,
                  sample_number: Union[int, List[int]] = None,
                  has_reg: bool = True):
        if item == 'samples':
            if sample_number is None:
                item = [str(i) for i in range(self.n_runs)]
            else:
                item = self._string_conversion(sample_number)
        method_key = method if method is not None else slice(None)
        key = [dataset if dataset is not None else slice(None),
               self._string_conversion(n_features) if n_features is not None else slice(None)]
        # select regression metrics if requested
        if has_reg:
            key.append(reg_metric if reg_metric is not None else slice(None))
        key.append(item if item is not None else slice(None))

        return method_key, tuple(key)

    def register_regression(self,
                            value,
                            dataset: Union[str, List[str]] = None,
                            method: Union[str, List[str]] = None,
                            n_features: Union[int, List[int]] = None,
                            reg_metric: Union[str, List[str]] = None,
                            item: Literal['mean', 'std', 'median', 'max', 'min', 'samples'] = None,
                            sample_number: int = None):
        method_key, key = self._make_key(dataset, method, n_features, reg_metric, item, sample_number)
        if type(value) == pd.DataFrame:
            self.reg_data.loc[(method_key, key)] = value.values.tolist()
        elif type(value) == np.array:
            self.reg_data.loc[(method_key, key)] = value.tolist()
        else:
            self.reg_data.loc[(method_key, key)] = value

    def register_selection(self,
                           dataset: str,
                           method: str,
                           n_features: int,
                           sample: int,
                           selection: np.array):
        with warnings.catch_warnings():
            warnings.filterwarnings("ignore")
            self.selection_data.loc[method,
                                    (dataset,
                                     self._string_conversion(n_features),
                                     str(sample))].iloc[:selection.shape[0]] = selection.tolist()

    def register_stability(self,
                           dataset: str,
                           n_features,
                           metric_name,
                           value,
                           method=None):
        self.stab_data.loc[method if method is not None else slice(None),
                           (dataset,
                            self._string_conversion(n_features),
                            metric_name)] = value

    def register_measurement(self,
                             value,
                             dataset: Union[str, List[str]] = None,
                             method: Union[str, List[str]] = None,
                             n_features: Union[int, List[int]] = None,
                             item: Literal['mean', 'std', 'median', 'max', 'min', 'samples'] = None,
                             sample_number: int = None):
        method_key, key = self._make_key(dataset, method, n_features, item=item, sample_number=sample_number, has_reg=False)
        if type(value) == pd.DataFrame:
            self.measurement_data.loc[(method_key, key)] = value.values.tolist()
        elif type(value) == np.array:
            self.measurement_data.loc[(method_key, key)] = value.tolist()
        else:
            self.measurement_data.loc[(method_key, key)] = value

    def get_regression_data(self,
                            dataset: Union[str, List[str]] = None,
                            method: Union[str, List[str]] = None,
                            n_features: Union[int, List[int]] = None,
                            reg_metric: Union[str, List[str]] = None,
                            item: Literal['mean', 'std', 'median', 'max', 'min', 'samples'] = None
                            ):
        """
            Retrieve data related to the regression performance of feature selection methods

            Parameters
            ----------
            dataset: Union[str, List[str]]
                dataset identifier or list of dataset identifiers
            method : str or list of str, default=None
                method(s) to be retrieved. If None, all methods are retrieved
            n_features : int, tuple of ints or list of int or of tuples of int, default=None
                results for the runs with the respective number of selected features to be retrieved. If None,
                the runs for all numbers of selected features are retrieved
            reg_metric : str or list of str, default=None
                regression metric(s) to be retrieved. If None, all available metrics are retrieved
            item : Literal of ['mean', 'std', 'median', 'max', 'min', 'samples'], default=None
                specify, which indicator(s) for the selected regression metrics is to be retrieved.
                If None, all indicators are retrieved

            Returns
            -------
            pandas multiIndex DataFrame sliced to the requested data
        """
        method_key, key = self._make_key(dataset, method, n_features, reg_metric, item)
        return self.reg_data.loc[(method_key, key)]

    def get_selection_data(self,
                           dataset: Union[str, List[str]] = None,
                           method: Union[str, List[str]] = None,
                           n_features: Union[int, Tuple[int], List[int], List[Tuple[int]]] = None,
                           sample_run: Union[int, List[int]] = None,
                           selected_features: Union[int, List[int]] = None):
        """
            Retrieve data related to the regression performance of feature selection methods.

            Parameters
            ----------
            method : str or list of str, default=None
                method(s) to be retrieved. If None, all methods are retrieved
            n_features : int or list of int, default=None
                results for the runs with the respective number of selected features to be retrieved. If None,
                the runs for all numbers of selected features are retrieved
           sample_run : int or list of int, default=None
                the run(s) for which the selected features are to be retrieved. If None, the selected features
                of all runs are retrieved.

            Returns
            -------
            pandas multiIndex DataFrame sliced to the requested data
        """

        # drop selected features added for padding in the dataframe if possible
        if n_features is not None \
                and type(n_features) != list \
                and selected_features is None:
            selected_features = [i for i in range(self._resolve_if_interval(n_features))]

        method_key = method if method is not None else slice(None)
        key = (
            dataset if dataset is not None else slice(None),
            self._string_conversion(n_features) if n_features is not None else slice(None),
            self._string_conversion(sample_run) if sample_run is not None else slice(None),
            self._string_conversion(selected_features) if selected_features is not None else slice(None)
        )

        with warnings.catch_warnings():
            warnings.filterwarnings("ignore")
            frame = self.selection_data.loc[method_key, key]
            return frame.sort_index(level=[0, 1])

    def get_stability_data(self,
                           dataset: Union[str, List[str]] = None,
                           method: Union[str, List[str]] = None,
                           n_features: Union[int, List[int]] = None,
                           stab_metric: Union[str, List[str]] = None):
        """
            Retrieve data related to the stability of feature selection methods

            Parameters
            ----------
            method : str or list of str, default=None
                method(s) to be retrieved. If None, all methods are retrieved
            n_features : int or list of int, default=None
                results for the runs with the respective number of selected features to be retrieved. If None,
                the runs for all numbers of selected features are retrieved
            stab_metric : str or list of str, default=None
                stability metric(s) to be retrieved. If None, all available metrics are retrieved

            Returns
            -------
            pandas multiindex DataFrame sliced to the requested data
        """

        # constructs multiIndex-slice
        method_key = method if method is not None else slice(None)
        key = (
               dataset if dataset is not None else slice(None),
               self._string_conversion(n_features) if n_features is not None else slice(None),
               stab_metric if stab_metric is not None else slice(None)
        )
        return self.stab_data.loc[(method_key, key)]

    def get_measurement_data(self,
                             dataset: Union[str, List[str]] = None,
                             method: Union[str, List[str]] = None,
                             n_features: Union[int, List[int]] = None,
                             item: Literal['mean', 'std', 'median', 'max', 'min', 'samples'] = None):
        method_key, key = self._make_key(dataset, method, n_features, item=item, has_reg=False)
        return self.measurement_data.loc[(method_key, key)]


    def store(self, file_path: str, file_name: str):
        path = os.path.join(file_path, f'{file_name}.pickle')
        with open(path, 'wb') as file:
            pickle.dump(self, file)



