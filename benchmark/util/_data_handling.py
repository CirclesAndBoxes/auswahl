import pandas as pd
import numpy as np
import os

from typing import List, Union, Literal

"""
    TODO: - Allow the handling of different datasets
          - include execution time --> fits perfectly into the regression frame

"""


class BenchmarkPOD:

    """
        Plain Old Dataobject corralling data generated by benchmarking different wavelength selection methods
    """

    def __init__(self,
                 methods: List,
                 n_features: List[int],
                 reg_metrics: List,
                 stab_metrics: List,
                 n_runs: int):

        reg_index, reg_size = self._build_multiindex([
            methods,
            n_features,
            reg_metrics,
            ['mean', 'std', *[f'sample_{i}' for i in range(n_runs)]]
        ])
        stab_index, stab_size = self._build_multiindex([
            methods,
            n_features,
            stab_metrics,
        ])
        selection_index, selection_size = self._build_multiindex([
            methods,
            n_features,
            [f'sample_{i}' for i in range(n_runs)],
            [f'feature_{i}' for i in range(max(n_features))]
        ])

        self.selection_data = pd.DataFrame(-1 * np.ones((selection_size,), dtype='int'), index=selection_index)
        self.stab_data = pd.DataFrame(np.zeros((stab_size,), dtype='float'), index=stab_index)
        self.reg_data = pd.DataFrame(np.zeros((reg_size,), dtype='float'), index=reg_index)

        # TODO: make these available via getters maybe
        self.methods = methods
        self.reg_metrics = reg_metrics
        self.stab_metrics = stab_metrics
        self.max_features = n_features
        self.n_runs = n_runs

        self.meta = dict()

    def _build_multiindex(self, structure: List[List[str]]):
        index = np.array([structure[-1]])
        for i in range(len(structure) - 2, -1, -1):
            index = np.concatenate([
                np.repeat([structure[i]], repeats=index.shape[1], axis=1),
                np.tile(index, (1, len(structure[i])))
            ])
        return index.tolist(), index.shape[1]

    def register_meta(self, **kwargs):
        for key in kwargs.keys():
            self.meta[key] = kwargs[key]

    def register_regression(self,
                            method_key: str,
                            n_features,
                            metric_name,
                            sample,
                            value):

        self.reg_data.loc[method_key,
                          str(n_features),
                          metric_name,
                          f'sample_{sample}'] = value

    def register_selection(self,
                           method_key: str,
                           n_features,
                           sample,
                           selection: np.array):
        print(self.selection_data.loc[(method_key,
                                 str(n_features),
                                 f'sample_{sample}')]) #.iloc[:selection.shape[0], 0] = selection.tolist()

    def register_stability(self,
                           method_key,
                           n_features,
                           metric_name,
                           value):
        self.stab_data.loc[(method_key,
                            str(n_features),
                            metric_name)] = value

    def _string_conversion(self, item):
        if type(item) == list:
            return [str(i) for i in item]
        return str(item)

    def get_regression_data(self,
                            method: Union[str, List[str]] = None,
                            n_features: Union[int, List[int]] = None,
                            reg_metric: Union[str, List[str]] = None,
                            item: Literal['mean', 'std', 'samples'] = None
                            ):
        """
            Retrieve data related to the regression performance of feature selection methods

            Parameters
            ----------
            method : str or list of str, default=None
                method(s) to be retrieved. If None, all methods are retrieved
            n_features : int or list of int, default=None
                results for the runs with the respective number of selected features to be retrieved. If None,
                the runs for all numbers of selected features are retrieved
            reg_metric : str or list of str, default=None
                regression metric(s) to be retrieved. If None, all available metrics are retrieved
            item : Literal of ['mean', 'std', 'samples'], default=None
                specify, which indicator(s) for the selected regression metrics is to be retrieved.
                If None, all indicators are retrieved

            Returns
            -------
            pandas multiIndex DataFrame sliced to the requested data
        """
        # constructs multiIndex-slice
        if item == 'samples':
            item = [f'samples_{i}' for i in range(self.n_runs)]
        key = (
                method if method is not None else slice(None),
                self._string_conversion(n_features) if n_features is not None else slice(None),
                reg_metric if reg_metric is not None else slice(None),
                item if item is not None else slice(None)
            )
        return self.reg_data.loc[key]

    def get_selection_data(self,
                           method: Union[str, List[str]] = None,
                           n_features: Union[int, List[int]] = None,
                           sample_run: Union[int, List[int]] = None):
        """
            Retrieve data related to the regression performance of feature selection methods

            Parameters
            ----------
            method : str or list of str, default=None
                method(s) to be retrieved. If None, all methods are retrieved
            n_features : int or list of int, default=None
                results for the runs with the respective number of selected features to be retrieved. If None,
                the runs for all numbers of selected features are retrieved
           sample_run : int or list of int, default=None
                the run(s) for which the selected features are to be retrieved. If None, the selected features
                of all runs are retrieved.

            Returns
            -------
            pandas multiIndex DataFrame sliced to the requested data
        """

        # constructs multiIndex-slice
        if sample_run is not None:
            if type(sample_run) == list:
                sample_run = [f'sample_{i}' for i in sample_run]
            else:
                sample_run = f'sample_{sample_run}'
        key = (
            method if method is not None else slice(None),
            self._string_conversion(n_features) if n_features is not None else slice(None),
            sample_run if sample_run is not None else slice(None)
        )
        # TODO: retrieve the non-negative elements --> not possible keeping the frame structure if n_features is a list
        return self.selection_data.loc[key]

    def get_stability_data(self,
                           method: Union[str, List[str]] = None,
                           n_features: Union[int, List[int]] = None,
                           stab_metric: Union[str, List[str]] = None):
        """
            Retrieve data related to the stability of feature selection methods

            Parameters
            ----------
            method : str or list of str, default=None
                method(s) to be retrieved. If None, all methods are retrieved
            n_features : int or list of int, default=None
                results for the runs with the respective number of selected features to be retrieved. If None,
                the runs for all numbers of selected features are retrieved
            stab_metric : str or list of str, default=None
                stability metric(s) to be retrieved. If None, all available metrics are retrieved

            Returns
            -------
            pandas multiindex DataFrame sliced to the requested data
        """

        # constructs multiIndex-slice
        key = (
            method if method is not None else slice(None),
            self._string_conversion(n_features) if n_features is not None else slice(None),
            stab_metric if stab_metric is not None else slice(None)
        )
        return self.stab_data.loc[key]
